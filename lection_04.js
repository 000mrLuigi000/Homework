/**
 * Создание массива из случайных чисел (1..100), так что они не повторяются.
 * 
 * Логика V1 
 * Основная идея - значение элемента есть индекс следоющего, поэтому первый элемент не может быть 1, а последний какраз еденица.
 * Причом все индексы массива будут на 1 меньше значения от которого берется индекс (например значение в ячейке 5, но следоющтй
 * заполняемый элемент на позиции 4)
 * 1. Создаеться масив с нулевым элементом, хранащее случайное значение.
 * 2. Стартует основной цикл while => пока обьщая сумма всех элеменотов (в данном случае 5050) больше 1.
 * 3. На каждый новый элемент массива запусакается второй цикл while => пока не break.
 * 3.1. В нем идет проверка на пустоту элемента, ксли true то генерируется новое число и сразу пременяется.
 *      Далее идет цикл с проверкой на туже пустоту (но id = значению в я чейке по предедущему id),
 *      поэтому пока значенее в следоющей ячейке не пустое, идет перебор новых значений будущего id.
 *      После выход из цикла.
 * 3.2. Если при основной проверке false то новое значение по ячейке текущего id меняется пока не true.
 * 4. Значение каждой новой ячейки вычитается из суммы.
 * 5. Остаток от суммы который = 1 записывается в последнюю пустую ячейку.
 * Состояние - выключена в связи с ограниченностью значений и трудностью понимания.
 * 
 * Логика V2
 * 1. Создвктся массив на 99 пустых элементов и последний = -1 (любое значение которе < 0).
 * 2. Он заполняется -1.
 * 3. При помощи foreach на каждый елемент запускается функция которая:
 * 3.1. Задает новое случайное значение.
 * 3.2. Если таких значений нет в массиве, то заносит его по текущему индексу, в противном случае задает значение заного.
 * 
 * @returns {Array} Построенный массив.
 */
function createArray() {
    // V1-----------------------------------------------------------------

    /* let kolvo = 100;
    let arr = [Math.floor(Math.random() * 1000) % (kolvo - 1) + 2];
    id = 1;
    schet = 5050 - arr[0];
    while (schet > 1) {
        let short_id;
        while (true) {
            if (!arr[arr[id - 1] - 1]) {
                short_id = Math.floor(Math.random() * 1000) % kolvo + 1;
                arr[arr[id - 1] - 1] = short_id;
                id = arr[id - 1];
                while (arr[arr[id - 1] - 1]) {
                    short_id = Math.floor(Math.random() * 1000) % kolvo + 1;
                    arr[id - 1] = short_id;
                }
                break;
            } else {
                short_id = Math.floor(Math.random() * 1000) % kolvo + 1;
                arr[id - 1] = short_id;
            }
        }
        schet -= short_id;
    }
    arr[arr[id - 1] - 1] = schet; 
    return arr; */

    //V2-----------------------------------------------------------------

    let arr = [];
    arr[99] = -1;
    arr.fill(-1,0,99);
    arr.forEach((value, index)=>{
        let shortNumber = Math.floor(Math.random() * 1000) % 100 + 1;
        while (!arr.every((value, index)=>{return value !== shortNumber})){
            shortNumber = Math.floor(Math.random() * 1000) % 100 + 1;
        }
        arr[index] = shortNumber;
    });
    return arr;
}

let arr1 = createArray();
console.log(arr1);

let arr2 = arr1.slice().reverse();
console.log(arr2);

let arr3 = [];
arr1.forEach((value,index)=>{
    arr3[index] = arr1[index] - arr2[index];
});
console.log(arr3);

let sum = arr3.reduce((summ,value)=>{
    return summ += value;
});
console.log(sum/arr3.length);